# Buildbot master configuration
#
# Copyright (C) 2017, ARM Limited, All Rights Reserved
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file is part of mbed TLS (https://tls.mbed.org)

from buildbot.plugins import status
from buildbot.status import html
from buildbot.status.web import authz, auth
from buildbot.config import BuilderConfig

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.

c = BuildmasterConfig = {}

def fuzzer_trigger( target, mode ):
	return "trigger_" + target + "_" + mode

def fuzzer_name( target, mode):
	return target + " " + mode

variants = [
#	"afl",
	"fast", "msan", "asan"]
targets = [
	"csr_parse_der",
	"crt_parse_der",
	"crl_parse_der",
	"pk_parse_key",
	"pk_parse_public_key",
	"crt_verify",
	"dhm_parse_dhm",
	"handshake",
	"ocsp_parse_response",
]

fuzzers = [ fuzzer_name( mode=v, target=t ) for v in variants for t in targets ]

from buildbot.plugins import util

build_lock = util.SlaveLock( "slave_builds", maxCount=1, maxCountForSlave={"fuzzer0" : 6} )

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
c['slaves'] = [
	BuildSlave("build", "pass"),
	BuildSlave("fuzzer0", "pass2")
]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

# TODO: the mbedtls-test repository is private, so an account with access to it
# needs to be set here, with a GitHub oauth token, see
# https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/

github_oauth_token = ''
github_user = ''

github_url = 'https://' + github_user + ':' + github_oauth_token + '@github.com/'
github_space = 'ARMmbed/'

github_mbedtls      = github_url + github_space + 'mbedtls-restricted.git'
github_mbedtls_test = github_url + github_space + 'mbedtls-test.git'

mbedtls_a_branch = 'master'
mbedtls_b_branch = 'master-1'
mbedtls_test_branch = 'master'

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

def codebaseGenerator( chdict ):
	repository = chdict['repository']
	branch = chdict['branch']

	if repository == github_mbedtls:
		if branch == mbedtls_a_branch:
			return 'mbedtls-a'
		elif branch == mbedtls_b_branch:
			return 'mbedtls-b'
		else:
			return ''
	elif repository == github_mbedtls_test:
		if branch == mbedtls_test_branch:
			return 'mbedtls-test'
		else:
			return ''

c['codebaseGenerator'] = codebaseGenerator

from buildbot.changes.gitpoller import GitPoller

mbedtls_poller = GitPoller(
	github_mbedtls,
	branches=[ mbedtls_a_branch, mbedtls_b_branch ],
	workdir='mbedtls-source',
	pollinterval=300,
	pollAtLaunch=False
)

mbedtls_test_poller = GitPoller(
	github_mbedtls_test,
	branches=[ mbedtls_test_branch ],
	workdir='mbedtls-test-source',
	pollinterval=300,
	pollAtLaunch=False
)

c['change_source'] = [ mbedtls_poller, mbedtls_test_poller ]

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.basic import SingleBranchScheduler,AnyBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.changes import filter
from buildbot.plugins import schedulers

codebases = {
	'mbedtls-a': {  'repository': github_mbedtls,
			'branch': mbedtls_a_branch },
	'mbedtls-b': {  'repository': github_mbedtls,
			'branch': mbedtls_b_branch },
	'mbedtls-test': { 'repository': github_mbedtls_test,
			  'branch': mbedtls_test_branch },
}

default_scheduler = AnyBranchScheduler(
	name="default",
	codebases=codebases,
	treeStableTimer=1,
	builderNames=[ "00build" ]
)

c['schedulers'] = []
c['schedulers'].append(ForceScheduler(
                            name="force",
			    codebases=codebases,
                            builderNames=["00build"]+fuzzers))
all_fuzzers = schedulers.Triggerable(name="fuzzers", builderNames=fuzzers)

individual_fuzzers = [
	schedulers.Triggerable( name=fuzzer_trigger( mode=v, target=t ),
				builderNames=[ fuzzer_name( mode=v, target=t ) ] )
		for v in variants for t in targets ]

c['schedulers'].append(all_fuzzers)
c['schedulers'].extend( individual_fuzzers )
c['schedulers'].append( default_scheduler )

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.plugins import steps, util

def fuzzer_run_cmd( target, mode ):
	return ["sudo", "docker", "run",
		"--log-driver", "none",
		"-v", util.Interpolate( "%(prop:workdir)s/build/:/fuzzing/bin" ),
		"-v", "fuzz_results:/fuzzing/results",
		"-v", "fuzz_corpora:/fuzzing/corpora",
		"mbedtls_fuzzer",
		"./scripts/run_fuzzer.sh",
		"--target", target,
		"--mode", mode]

build_file_name = util.WithProperties( "/var/lib/buildbot/builds/build-a@%(mbedtls_a)s-b@%(mbedtls_b)s-test@%(mbedtls_test)s.tar.gz",
		mbedtls_a=lambda x: get_codebase_revision( x, 'mbedtls-a' ),
		mbedtls_b=lambda x: get_codebase_revision( x, 'mbedtls-b' ),
		mbedtls_test=lambda x: get_codebase_revision( x, 'mbedtls-test' ) )

c['builders'] = []
fuzz_slaves = ["fuzzer0"]

def fuzzerMergeRequests( builder, req1, req2 ):
	return True

for v in variants:
	for t in targets:
		factory = BuildFactory()
		factory.addStep( Git( codebase='mbedtls-test', repourl=github_mbedtls_test, branch=mbedtls_test_branch, workdir="source/mbedtls_test", alwaysUseLatest=True ) )
		factory.addStep( Git( codebase='mbedtls-a', repourl=github_mbedtls, branch=mbedtls_a_branch, workdir="source/mbedtls", alwaysUseLatest=True ) )
		factory.addStep( Git( codebase='mbedtls-b', repourl=github_mbedtls, branch=mbedtls_b_branch, workdir="source/mbedtls", alwaysUseLatest=True ) )
		factory.addStep( ShellCommand( command="sudo docker build --rm fuzzing/fuzz_infra -t fuzz_infra", workdir="source/mbedtls_test", haltOnFailure=True ) )
		factory.addStep( ShellCommand( command="sudo docker build --rm fuzzing/fuzzer -t mbedtls_fuzzer", workdir="source/mbedtls_test", haltOnFailure=True ) )
		factory.addStep( steps.FileDownload( mastersrc=build_file_name, slavedest="build.tar.gz" ) )
		factory.addStep( ShellCommand( command="tar xf build.tar.gz" ) )
		factory.addStep( ShellCommand( command=fuzzer_run_cmd( mode=v, target=t ),
			haltOnFailure=True,
			timeout=None,
			interruptSignal="TERM" ) )
		factory.addStep( steps.Trigger( schedulerNames=[ fuzzer_trigger( mode=v, target=t ) ] ) )
		c['builders'].append( BuilderConfig(
			name=fuzzer_name( mode=v, target=t ),
			slavenames=fuzz_slaves,
			factory=factory,
			locks=[build_lock.access('counting')],
			mergeRequests=fuzzerMergeRequests ) )

build_factory = BuildFactory( )
build_factory.addStep( Git( codebase='mbedtls-test', repourl=github_mbedtls_test, branch=mbedtls_test_branch, workdir="source/mbedtls_test" ) )
build_factory.addStep( Git( codebase='mbedtls-a', repourl=github_mbedtls, branch=mbedtls_a_branch, workdir="source/tls/mbedtls_a" ) )
build_factory.addStep( Git( codebase='mbedtls-b', repourl=github_mbedtls, branch=mbedtls_b_branch, workdir="source/tls/mbedtls_b" ) )
build_factory.addStep( ShellCommand( command="sudo docker build --rm fuzzing/fuzz_infra -t fuzz_infra", haltOnFailure=True, workdir="source/mbedtls_test" ) )
build_factory.addStep( ShellCommand( command="sudo docker build --rm fuzzing/builder -t mbedtls_builder", haltOnFailure=True, workdir="source/mbedtls_test" ) )
cmd = [
	"sudo",
	"mbedtls_test/fuzzing/builder/run.sh",
	util.Interpolate( "%(prop:workdir)s/source/tls/." ),
	util.Interpolate( "%(prop:workdir)s/source/mbedtls_test/fuzzing/src/." ),
	util.Interpolate( "%(prop:workdir)s/build/." )
]
build_factory.addStep( ShellCommand( command=cmd, workdir='source', haltOnFailure=True ) )
build_factory.addStep( ShellCommand( command="tar cf build.tar.gz ." ) )
def get_codebase_revision( props, codebase ):
	if props.has_key( 'got_revision' ):
		return props['got_revision'][codebase][0:6]
	return None

build_factory.addStep( steps.FileUpload(
			slavesrc="build.tar.gz",
			masterdest=build_file_name
			) )
build_factory.addStep(steps.Trigger(schedulerNames=["fuzzers"]))
c['builders'].append( BuilderConfig( name="00build", slavenames=["build"], factory=build_factory ) )

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth([("mbedtls","mbedtls")]),
    gracefulShutdown = False,
    forceBuild = True,
    forceAllBuilds = False,
    pingBuilder = False,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = False,
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

mn = status.MailNotifier(
	fromaddr="mbedtls@e108746.cambridge.arm.com",
	sendToInterestedUsers=False,
	extraRecipients=[ "jaeden.amero@arm.com", "azim.khan@arm.com" ],
	relayhost="mail.arm.com",
	addLogs=True,
	mode="failing"
	)
c['status'].append(mn)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Mbed TLS CFI"
c['titleURL'] = "https://tls.mbed.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://e108746.cambridge.arm.com:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
