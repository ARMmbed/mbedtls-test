# Fuzzing mbed TLS

Fuzz testing is the art of automatically generating random inputs to find
faults, such as crashes, asserts, or memory leaks, buffer overflows etc.

With AFL, fuzzers have started using information about which paths are
exercised by an input to determine its usefulness. Fuzzers based on this
technique are often much better in generating "interesting" inputs to a
program.

libFuzzer incorporates many of AFl's techniques while using the llvm
infrastructure to improve on efficiency and utilise the various sanitisers.

Fuzzing targets are entry points into a program where random data can be
accepted, e.g. a parser. Good targets are functions that process untrusted
data. A fuzzing target should be accompanied by a fuzzing corpus, a set of
test cases that exercises different paths in the code.

This README gives further details about how to run the included fuzzers.

For more information about the investigated fuzzers look
[here](https://confluence.arm.com/display/IoTBU/mbed+TLS+fuzzing+tools+analysis).

## Prerequisites

All you need is Docker. Install Docker from [here](www.docker.com) or through
your preferred package manager. Version 17.06.0 community edition is known to
work.

The scripts to manage the building and running of the Docker images are written
in POSIX shell and expect a Unix-like environment. This is not a hard
requirement, though; you can invoke `docker` directly instead. (Note that this
has not been tested on anything but a Unix environment, specifically, Ubuntu
16.04 LTS.)

That's it! Everything else is installed and built as part of the Docker image
build process.

## Setup

The tools for fuzzing mbed TLS are provided as a Docker image. The `fuzz_infra`
image has the required fuzzing tools installed, while the second image (tagged
`mbedtls-fuzzing-tmp` by default) sets up the various builds of mbed TLS and
compiles the fuzzing targets. `./build.sh` builds both images.

The mbed TLS source is pulled in from the `mbedtls_src` directory. A good way
to set this up is by creating a git worktree as follows. (Note that any branch
can only be checked out once. Also note that this is a rather new feature of
git, available since 2.6.0.)

```
cd /path/to/mbedtls-git-repository
git worktree /path/to/mbedtls-test/fuzzing/mbedtls_src
```

The usual git commands work inside `mbedtls_src` without `.git` containing the
full git history.

After setting `mbedtls_src` to the branch you want to fuzz, run `./build.sh`.
It accepts `--tag` to tag the mbed TLS image in Docker. It's a good
idea to use the tag to indicate which revision of mbed TLS is included in the
image.

```
sudo ./build.sh --tag development
```

## Running a fuzzer

The `./run.sh` script is a wrapper around Docker's `run` command. It accepts
`-i`, or `--image`, as specification of a Docker image (e.g. its tag). `-r`, or
`--results`, can be used to set the directory where results are collected. By
default, this is `/scratch/mbedtls/results/`. Most of the time, a single
results directory can be used. Occasionally it is necessary to use separate
results directories. This is especially the case when fuzzing the same target
for different revisions of mbed TLS at the same time.

The arguments after the last option are passed to `docker run`.

The `./scripts/run_fuzzer.sh` script can be used to start any of the supported
fuzzers. The `--mode` option is used to specify which fuzzers are to be run.
The modes `fast`, `asan`, and `msan` start libFuzzer fuzzers with optimisations
and no sanitizers, address sanitizer, and memory sanitizer respectively. The
mode `all` starts all libFuzzers in parallel. Finally, `--mode afl` starts the
AFL fuzzer for the target specified with `-t` or `--target`.

See the next section for the results from running these commands.

```
sudo ./run.sh -r $results_dir -i $image ./scripts/run_fuzzer.sh --mode all -t $fuzz_target
sudo ./run.sh -r $results_dir -i $image ./scripts/run_fuzzer.sh --mode afl -t $fuzz_target
```

To list all available fuzz targets, run `run_fuzzer.sh` without a `-t` option.

Note that AFL requires some host kernel settings to be modified. On first run,
it will guide the user through this (so don't be alarmed!). For more
information, see the [afl performance
tips](https://github.com/mirrorer/afl/blob/master/docs/perf_tips.txt).

## Results

The results structure is as follows:

- `fuzz_target/afl/{queue,crashes,hangs}`
                  test cases generated by AFL; all crashes found by AFL; and
                  all hangs found by AFL. This organisation is dictated by AFL.

- `fuzz_target/libfuzzer/crashes`
                  interesting files from libFuzzer, such as crashes and leaks.
                  libFuzzer's interesting files are always placed in the
                  current working directory, so the fuzzers are run with this
                  directory as working directory

- `fuzz_target/libfuzzer/queue`
                - test cases generated by libFuzzer. The fuzzer command takes
                  this as its first argument, so this is where new inputs are
                  written. The libFuzzer variants (fast, asan, msan) use this
                  directory to synchronize new inputs between themselves.

To collect the results into a new corpus, run the `./regen_corpus.sh` script.

```
sudo ./regen_corpus.sh -t fuzz_target -r results_dir -i image
```

This results in a new (or updated) corpus in `./corpora/fuzz_target/`, based on
AFL and libFuzzer results in `results_dir/fuzz_target/` and the previous
corpus. The corpus is then automatically picked up by all fuzzers (AFL and
libFuzzer).

## Reproducing

Once a fuzzer finds a problem, you might want to reproduce the issue without
the fuzzer. You could either reproduce inside the Docker image, or outside.
Reproducing outside the Docker image is likely to be a bit more work, since the
image includes all the necessary executables.

The process for finding the reproducing example is differs whether the fuzzer
is libFuzzer or AFL. AFL will show if there are failures (crashes) in its
curses interface, or in its summary file. AFL reproducers are stored in
`$results/$target/out/crashes`. libFuzzer stores crashes as
`$results/$target/crash-*`. The file name will be printed by libFuzzer together
with a stack trace.

Once you have located the test case, you can use the `standalone` programs to
reproduce the problem without the fuzzer. There are variants for `fast`,
`msan`, and `asan`. The stack trace from the log will give a hint as to which
sanitizer you might need, but it might be necessary to just try all of them.
In theory, a crash found by AFL should also reproduce with
`bin/standalone_fast_$target`. If not, the `bin/afl_$target` will work.

If you want to reproduce outside of the Docker image, you'll need to
1.  get a build of Mbed TLS with the right sanitizer (see previous paragraph),
    and `-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION`
2.  compile `StandaloneFuzzTargetMain.c` from the libFuzzer repository
3.  build the fuzz target (again, with the right sanitizer)
4.  link the two object files with Mbed TLS (again, use the right sanitizer to
    pick up the correct runtime libraries)

Happy debugging!
